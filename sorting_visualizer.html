<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ソートアルゴリズム可視化ツール</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f7f9fc;
            margin: 0;
            padding: 0;
            color: #1f2a44;
        }
        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 20px 24px 40px;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            padding: 6px 14px;
            border-radius: 6px;
            background-color: #f0f4ff;
            color: #1a4fbf;
            text-decoration: none;
            font-weight: bold;
        }
        .back-link:hover {
            background-color: #d9e4ff;
        }
        h1 {
            margin: 0 0 12px;
        }
        p.description {
            margin-top: 0;
            color: #4b5567;
        }
        .layout {
            display: flex;
            gap: 24px;
            align-items: flex-start;
        }
        .sidebar {
            flex: 3;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .main-area {
            flex: 7;
            min-height: 320px;
        }
        .controls, .actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            margin-bottom: 16px;
            background-color: #fff;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }
        .controls label,
        .actions label {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .controls input[type="number"] {
            width: 90px;
            padding: 4px 6px;
        }
        button {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background-color: #4a90e2;
            color: white;
            font-weight: bold;
        }
        button:disabled {
            background-color: #9fbbe0;
            cursor: not-allowed;
        }
        button.secondary {
            background-color: #6b7a99;
        }
        .algorithms {
            background-color: #fff;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            margin-bottom: 16px;
        }
        .algorithm-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px 18px;
            margin-top: 8px;
        }
        .algorithm-options label {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        #sequenceDisplay {
            margin-bottom: 18px;
            font-family: "Courier New", Courier, monospace;
            background-color: #fff;
            padding: 10px 14px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            min-height: 38px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 6px;
        }
        .alert {
            background-color: #ffe1e1;
            color: #8a1c1c;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 16px;
        }
        .alert.hidden {
            display: none;
        }
        .panels {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .panel {
            background-color: #fff;
            padding: 14px 16px 18px;
            border-radius: 10px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 10px;
        }
        .panel-header h3 {
            margin: 0;
            font-size: 18px;
        }
        .timer {
            font-size: 14px;
            color: #4b5567;
        }
        .bars {
            position: relative;
            flex: 1;
            display: flex;
            align-items: stretch;
            justify-content: stretch;
            height: 240px;
            padding: 24px 18px 34px 58px;
            background-color: #f6f8fb;
            border-radius: 8px;
            border: 1px solid #e3e9f5;
            overflow: hidden;
        }
        .bars-wrapper {
            position: absolute;
            left: 58px;
            right: 18px;
            top: 24px;
            bottom: 34px;
            display: flex;
            align-items: flex-end;
            justify-content: flex-start;
            gap: var(--bar-gap, 1px);
            overflow: hidden;
        }
        .y-axis {
            position: absolute;
            left: 16px;
            top: 24px;
            bottom: 34px;
            width: 36px;
            font-size: 11px;
            color: #5d6c8b;
            pointer-events: none;
        }
        .y-tick {
            position: absolute;
            left: 0;
            transform: translateY(50%);
        }
        .y-tick.top {
            transform: translateY(-50%);
        }
        .y-tick.bottom {
            transform: translateY(0);
        }
        .y-grid {
            position: absolute;
            left: 58px;
            right: 18px;
            top: 24px;
            bottom: 34px;
            pointer-events: none;
        }
        .y-line {
            position: absolute;
            left: 0;
            right: 0;
            border-top: 1px dashed #d6e0f5;
        }
        .bar {
            flex: 0 0 var(--bar-width, 6px);
            width: var(--bar-width, 6px);
            min-width: 0;
            min-height: 12px;
            border-radius: 4px 4px 0 0;
            background: linear-gradient(180deg, #7aa6ff, #3c6fe7);
            transition: height 0.13s ease, background-color 0.13s ease;
        }
        .bar.highlight {
            background: linear-gradient(180deg, #ff9387, #ff4c39);
        }
        .status {
            margin-top: 10px;
            min-height: 18px;
            font-size: 14px;
            color: #4b5567;
        }
        .actions input[type="range"] {
            width: 160px;
        }
        .actions select {
            padding: 4px 6px;
            border-radius: 4px;
            border: 1px solid #c3cde4;
            background-color: #fff;
            font-size: 14px;
            color: #1f2a44;
        }
        .speed-label span {
            font-size: 12px;
            color: #4b5567;
        }
        @media (max-width: 900px) {
            .layout {
                flex-direction: column;
            }
            .sidebar, .main-area {
                width: 100%;
            }
        }
        @media (max-width: 680px) {
            .controls, .actions {
                flex-direction: column;
                align-items: flex-start;
            }
            .panel {
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a class="back-link" href="index.html">← インデックスへ戻る</a>
        <h1>ソートアルゴリズム可視化ツール</h1>
        <p class="description">最大5種類のソートを同じ配列で比較できます。速度や要素数を調整しながら、各アルゴリズムの動きを観察してください。</p>

        <div class="layout">
            <div class="sidebar">
                <div class="controls">
                    <label for="elementCount">要素数:
                        <input type="number" id="elementCount" min="5" max="1000" value="20">
                    </label>
                    <button id="randomizeBtn" class="secondary">ランダム配列生成</button>
                    <span style="font-size:13px;color:#6b7a99;">※配列は選択したソートで共有されます</span>
                </div>

                <div id="sequenceDisplay"></div>

                <div class="algorithms">
                    <strong>アルゴリズムを選択（最大5つ）</strong>
                    <div class="algorithm-options" id="algorithmOptions"></div>
                </div>

                <div class="actions">
                    <button id="startBtn">ソートを開始</button>
                    <button id="stopBtn" class="secondary" disabled>強制停止</button>
                    <label class="speed-label">描画間隔:
                        <input type="range" id="speedRange" min="15" max="220" value="80">
                        <span id="speedValue">80ms</span>
                    </label>
                    <label class="timeout-label">タイムアウト:
                        <select id="timeoutSelect">
                            <option value="1">1分</option>
                            <option value="2" selected>2分</option>
                            <option value="3">3分</option>
                            <option value="4">4分</option>
                            <option value="5">5分</option>
                        </select>
                    </label>
                </div>

                <div id="alert" class="alert hidden"></div>
            </div>
            <div class="main-area">
                <div id="panels" class="panels"></div>
            </div>
        </div>
    </div>

    <script>
        const MAX_ALGORITHMS = 5;
        const algorithms = {
            bubble: { key: "bubble", label: "バブルソート", generator: bubbleSortSteps },
            insertion: { key: "insertion", label: "挿入ソート", generator: insertionSortSteps },
            selection: { key: "selection", label: "選択ソート", generator: selectionSortSteps },
            cocktail: { key: "cocktail", label: "カクテルソート", generator: cocktailSortSteps },
            quick: { key: "quick", label: "クイックソート", generator: quickSortSteps },
            merge: { key: "merge", label: "マージソート", generator: mergeSortSteps },
            heap: { key: "heap", label: "ヒープソート", generator: heapSortSteps },
            shell: { key: "shell", label: "シェルソート", generator: shellSortSteps },
            gnome: { key: "gnome", label: "ノームソート", generator: gnomeSortSteps },
            radix: { key: "radix", label: "基数ソート", generator: radixSortSteps }
        };

        const DEFAULT_BAR_GAP = 1;
        const LARGE_BAR_COUNT_THRESHOLD = 160;

        let currentArray = [];

        const elementCountInput = document.getElementById("elementCount");
        const randomizeBtn = document.getElementById("randomizeBtn");
        const startBtn = document.getElementById("startBtn");
        const stopBtn = document.getElementById("stopBtn");
        const algorithmOptions = document.getElementById("algorithmOptions");
        const panelsContainer = document.getElementById("panels");
        const alertBox = document.getElementById("alert");
        const sequenceDisplay = document.getElementById("sequenceDisplay");
        const speedRange = document.getElementById("speedRange");
        const speedValue = document.getElementById("speedValue");
        const timeoutSelect = document.getElementById("timeoutSelect");
        let activeRunControllers = [];

        init();

        function init() {
            renderAlgorithmOptions();
            generateNewArray();
            updateSequenceDisplay();
            speedRange.addEventListener("input", () => {
                speedValue.textContent = speedRange.value + "ms";
            });
            randomizeBtn.addEventListener("click", () => {
                generateNewArray();
                updateSequenceDisplay();
                panelsContainer.innerHTML = "";
            });
            elementCountInput.addEventListener("change", () => {
                clampElementCount();
                generateNewArray();
                updateSequenceDisplay();
                panelsContainer.innerHTML = "";
            });
            startBtn.addEventListener("click", startVisualization);
            stopBtn.addEventListener("click", stopAllRuns);
        }

        function renderAlgorithmOptions() {
            Object.values(algorithms).forEach(algo => {
                const id = `algo-${algo.key}`;
                const label = document.createElement("label");
                const input = document.createElement("input");
                input.type = "checkbox";
                input.value = algo.key;
                input.id = id;
                label.appendChild(input);
                const text = document.createTextNode(algo.label);
                label.appendChild(text);
                algorithmOptions.appendChild(label);
            });
        }

        function clampElementCount() {
            const min = parseInt(elementCountInput.min, 10);
            const max = parseInt(elementCountInput.max, 10);
            let value = parseInt(elementCountInput.value, 10);
            if (Number.isNaN(value)) value = min;
            value = Math.min(Math.max(value, min), max);
            elementCountInput.value = value;
            return value;
        }

        function generateNewArray() {
            const count = clampElementCount();
            currentArray = Array.from({ length: count }, () => Math.floor(Math.random() * 90) + 10);
        }

        function updateSequenceDisplay() {
            sequenceDisplay.innerHTML = "";
            currentArray.forEach(value => {
                const span = document.createElement("span");
                span.textContent = value;
                span.style.padding = "4px 6px";
                span.style.borderRadius = "4px";
                span.style.backgroundColor = "#eef3ff";
                span.style.color = "#2b3d6b";
                sequenceDisplay.appendChild(span);
            });
        }

        function startVisualization() {
            hideAlert();
            const selectedKeys = Array.from(algorithmOptions.querySelectorAll("input[type='checkbox']:checked")).map(el => el.value);
            if (selectedKeys.length === 0) {
                showAlert("最低でも1つのアルゴリズムを選択してください。");
                return;
            }
            if (selectedKeys.length > MAX_ALGORITHMS) {
                showAlert(`選択できるのは最大 ${MAX_ALGORITHMS} 種類までです。`);
                return;
            }

            const arrayClone = [...currentArray];
            const delay = parseInt(speedRange.value, 10);
            const timeoutMinutes = parseInt(timeoutSelect.value, 10);
            const timeoutMs = timeoutMinutes * 60000;

            panelsContainer.innerHTML = "";
            startBtn.disabled = true;
            randomizeBtn.disabled = true;
            stopBtn.disabled = false;
            activeRunControllers = [];

            const tasks = selectedKeys.map(key => {
                const controller = createRunController();
                activeRunControllers.push(controller);
                return runVisualizationForAlgorithm(key, arrayClone, delay, timeoutMs, timeoutMinutes, controller);
            });

            Promise.allSettled(tasks).finally(() => {
                startBtn.disabled = false;
                randomizeBtn.disabled = false;
                stopBtn.disabled = true;
                activeRunControllers = [];
            });
        }

        function stopAllRuns() {
            if (activeRunControllers.length === 0) {
                return;
            }
            activeRunControllers.forEach(controller => controller.cancel());
            stopBtn.disabled = true;
        }

        function createRunController() {
            let cancelled = false;
            return {
                cancel() {
                    cancelled = true;
                },
                get cancelled() {
                    return cancelled;
                }
            };
        }

        async function runVisualizationForAlgorithm(key, baseArray, delay, timeoutMs, timeoutMinutes, controller) {
            const algo = algorithms[key];
            const panel = createPanel(algo.label);
            panelsContainer.appendChild(panel.container);

            const { timerEl, statusEl, barsContainer } = panel;
            statusEl.textContent = "実行中...";

            const array = [...baseArray];
            const stepsStart = performance.now();

            let steps;
            try {
                steps = algo.generator(array);
            } catch (err) {
                statusEl.textContent = "ステップ生成に失敗しました。";
                console.error(err);
                return;
            }

            if (!Array.isArray(steps) || steps.length === 0) {
                steps = [{ array: [...array], highlights: [] }];
            }

            const generationTime = performance.now() - stepsStart;
            const timerController = createTimer(timerEl);
            timerController.start();

            const overallMax = findMaxValueInSteps(steps);
            const initialScale = getScaleFromMax(overallMax);
            const barsState = createBars(barsContainer, steps[0]?.array || array, initialScale);

            let timedOut = false;
            let forcedStop = false;
            const timeoutAt = performance.now() + timeoutMs;

            for (let i = 0; i < steps.length; i++) {
                if (controller.cancelled) {
                    forcedStop = true;
                    break;
                }

                const step = steps[i];
                updateBars(barsState, step.array, step.highlights);

                if (controller.cancelled) {
                    forcedStop = true;
                    break;
                }

                if (performance.now() > timeoutAt) {
                    timedOut = true;
                    break;
                }

                if (i < steps.length - 1) {
                    await wait(delay);
                    if (performance.now() > timeoutAt) {
                        timedOut = true;
                        break;
                    }
                    if (controller.cancelled) {
                        forcedStop = true;
                        break;
                    }
                }
            }

            timerController.stop();

            if (controller.cancelled || forcedStop) {
                statusEl.textContent = "強制停止しました。";
                return;
            }

            if (timedOut) {
                statusEl.textContent = `タイムアウト(${timeoutMinutes}分)しました。描画を停止しました。`;
            } else {
                statusEl.textContent = `完了 (${timerController.elapsedMs.toFixed(0)}ms / ステップ生成 ${generationTime.toFixed(1)}ms)`;
            }
        }

        function createPanel(title) {
            const container = document.createElement("div");
            container.className = "panel";

            const header = document.createElement("div");
            header.className = "panel-header";

            const h3 = document.createElement("h3");
            h3.textContent = title;

            const timerEl = document.createElement("span");
            timerEl.className = "timer";
            timerEl.textContent = "0.0s";

            header.appendChild(h3);
            header.appendChild(timerEl);

            const barsContainer = document.createElement("div");
            barsContainer.className = "bars";

            const statusEl = document.createElement("div");
            statusEl.className = "status";

            container.appendChild(header);
            container.appendChild(barsContainer);
            container.appendChild(statusEl);

            return { container, timerEl, statusEl, barsContainer };
        }

        function createBars(container, values, initialScale) {
            container.innerHTML = "";

            const axis = document.createElement("div");
            axis.className = "y-axis";
            container.appendChild(axis);

            const grid = document.createElement("div");
            grid.className = "y-grid";
            container.appendChild(grid);

            const wrapper = document.createElement("div");
            wrapper.className = "bars-wrapper";
            container.appendChild(wrapper);

            const wrapperHeight = wrapper.clientHeight || 200;
            const scale = initialScale || getScaleFromMax(Math.max(...values, 1));
            const layout = calculateBarLayout(wrapper, values.length);
            wrapper.style.setProperty('--bar-gap', `${layout.gap}px`);

            const state = {
                axis,
                grid,
                wrapper,
                bars: [],
                wrapperHeight,
                scale,
                barWidth: layout.width,
                gap: layout.gap
            };

            updateYAxis(axis, grid, state.scale);

            state.bars = values.map(value => {
                const bar = document.createElement("div");
                bar.className = "bar";
                applyBarWidth(bar, state.barWidth);
                bar.style.height = calculateBarHeight(value, state.scale.max, wrapperHeight);
                wrapper.appendChild(bar);
                return bar;
            });

            return state;
        }

        function updateBars(state, values, highlights = []) {
            const wrapperHeight = state.wrapper.clientHeight || state.wrapperHeight || 200;
            state.wrapperHeight = wrapperHeight;

            const currentMax = Math.max(...values, 0);
            if (currentMax > state.scale.max || currentMax < state.scale.max / 4) {
                state.scale = getScaleFromMax(Math.max(currentMax, 1));
                updateYAxis(state.axis, state.grid, state.scale);
            }

            const layout = calculateBarLayout(state.wrapper, values.length);
            if (Math.abs(layout.width - state.barWidth) > 0.1 || layout.gap !== state.gap) {
                state.barWidth = layout.width;
                state.gap = layout.gap;
                state.wrapper.style.setProperty('--bar-gap', `${state.gap}px`);
                state.bars.forEach(bar => applyBarWidth(bar, state.barWidth));
            }

            if (values.length > state.bars.length) {
                for (let i = state.bars.length; i < values.length; i++) {
                    const bar = document.createElement("div");
                    bar.className = "bar";
                    applyBarWidth(bar, state.barWidth);
                    state.wrapper.appendChild(bar);
                    state.bars.push(bar);
                }
            } else if (values.length < state.bars.length) {
                while (state.bars.length > values.length) {
                    const bar = state.bars.pop();
                    if (bar) bar.remove();
                }
            }

            state.bars.forEach((bar, index) => {
                const value = values[index] ?? 0;
                applyBarWidth(bar, state.barWidth);
                bar.style.height = calculateBarHeight(value, state.scale.max, wrapperHeight);
                bar.classList.toggle("highlight", highlights.includes(index));
            });
        }

        function calculateBarLayout(wrapper, count) {
            const rect = wrapper.getBoundingClientRect();
            const wrapperWidth = rect.width || wrapper.clientWidth || 0;
            if (count <= 0 || wrapperWidth <= 0) {
                return { width: 0, gap: DEFAULT_BAR_GAP };
            }

            let gap = count > LARGE_BAR_COUNT_THRESHOLD ? 0 : DEFAULT_BAR_GAP;
            let available = wrapperWidth - gap * Math.max(0, count - 1);
            if (available < 0) {
                gap = 0;
                available = wrapperWidth;
            }

            const width = available / count;
            return {
                width: Math.max(width, 0),
                gap
            };
        }

        function applyBarWidth(bar, width) {
            const safeWidth = Math.max(width, 0);
            bar.style.setProperty('--bar-width', `${safeWidth}px`);
        }

        function updateYAxis(axisEl, gridEl, scale) {
            const tickCount = 4;
            axisEl.innerHTML = "";
            gridEl.innerHTML = "";
            for (let i = 0; i <= tickCount; i++) {
                const ratio = i / tickCount;
                const value = Math.max(scale.max - scale.step * i, 0);
                const tick = document.createElement("div");
                tick.className = "y-tick";
                if (i === 0) tick.classList.add("top");
                if (i === tickCount) tick.classList.add("bottom");
                tick.style.bottom = `${ratio * 100}%`;
                tick.textContent = Math.round(value);
                axisEl.appendChild(tick);

                if (i !== tickCount) {
                    const line = document.createElement("div");
                    line.className = "y-line";
                    line.style.bottom = `${ratio * 100}%`;
                    gridEl.appendChild(line);
                }
            }
        }

        function getScaleFromMax(maxValue, tickCount = 4) {
            const safeMax = Math.max(maxValue, 1);
            let step = niceNumber(safeMax / tickCount, true);
            let niceMax = step * tickCount;
            while (niceMax < safeMax) {
                step = niceNumber(step * 1.5, true);
                niceMax = step * tickCount;
            }
            return { max: niceMax, step };
        }

        function niceNumber(range, round) {
            if (range === 0) {
                return 1;
            }
            const exponent = Math.floor(Math.log10(range));
            const fraction = range / Math.pow(10, exponent);
            let niceFraction;

            if (round) {
                if (fraction < 1.5) niceFraction = 1;
                else if (fraction < 3) niceFraction = 2;
                else if (fraction < 7) niceFraction = 5;
                else niceFraction = 10;
            } else {
                if (fraction <= 1) niceFraction = 1;
                else if (fraction <= 2) niceFraction = 2;
                else if (fraction <= 5) niceFraction = 5;
                else niceFraction = 10;
            }

            return niceFraction * Math.pow(10, exponent);
        }

        function findMaxValueInSteps(steps) {
            let maxValue = 0;
            steps.forEach(step => {
                if (!step || !Array.isArray(step.array)) return;
                for (let i = 0; i < step.array.length; i++) {
                    if (step.array[i] > maxValue) {
                        maxValue = step.array[i];
                    }
                }
            });
            return maxValue;
        }

        function calculateBarHeight(value, maxScale, availableHeight) {
            const normalized = maxScale === 0 ? 0 : value / maxScale;
            const maxDrawable = Math.max(availableHeight - 4, 12);
            const height = Math.max(12, Math.min(normalized * availableHeight, maxDrawable));
            return `${height}px`;
        }

        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function createTimer(timerEl) {
            let startTime = 0;
            let rafId = null;
            const controller = {
                elapsedMs: 0,
                start() {
                    startTime = performance.now();
                    const tick = () => {
                        controller.elapsedMs = performance.now() - startTime;
                        timerEl.textContent = (controller.elapsedMs / 1000).toFixed(1) + "s";
                        rafId = requestAnimationFrame(tick);
                    };
                    tick();
                },
                stop() {
                    if (rafId !== null) {
                        cancelAnimationFrame(rafId);
                        rafId = null;
                    }
                    timerEl.textContent = (controller.elapsedMs / 1000).toFixed(1) + "s";
                }
            };
            return controller;
        }

        function showAlert(message) {
            alertBox.textContent = message;
            alertBox.classList.remove("hidden");
        }

        function hideAlert() {
            alertBox.classList.add("hidden");
        }

        // ---- Sorting step generators ----

        function bubbleSortSteps(array) {
            const arr = [...array];
            const steps = [{ array: [...arr], highlights: [] }];
            const n = arr.length;
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    steps.push({ array: [...arr], highlights: [j, j + 1] });
                    if (arr[j] > arr[j + 1]) {
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                        steps.push({ array: [...arr], highlights: [j, j + 1] });
                    }
                }
            }
            steps.push({ array: [...arr], highlights: [] });
            return steps;
        }

        function insertionSortSteps(array) {
            const arr = [...array];
            const steps = [{ array: [...arr], highlights: [] }];
            for (let i = 1; i < arr.length; i++) {
                let key = arr[i];
                let j = i - 1;
                steps.push({ array: [...arr], highlights: [i] });
                while (j >= 0 && arr[j] > key) {
                    arr[j + 1] = arr[j];
                    steps.push({ array: [...arr], highlights: [j, j + 1] });
                    j--;
                }
                arr[j + 1] = key;
                steps.push({ array: [...arr], highlights: [j + 1] });
            }
            steps.push({ array: [...arr], highlights: [] });
            return steps;
        }

        function selectionSortSteps(array) {
            const arr = [...array];
            const steps = [{ array: [...arr], highlights: [] }];
            const n = arr.length;
            for (let i = 0; i < n - 1; i++) {
                let minIdx = i;
                for (let j = i + 1; j < n; j++) {
                    steps.push({ array: [...arr], highlights: [minIdx, j] });
                    if (arr[j] < arr[minIdx]) {
                        minIdx = j;
                    }
                }
                if (minIdx !== i) {
                    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                    steps.push({ array: [...arr], highlights: [i, minIdx] });
                }
            }
            steps.push({ array: [...arr], highlights: [] });
            return steps;
        }

        function cocktailSortSteps(array) {
            const arr = [...array];
            const steps = [{ array: [...arr], highlights: [] }];
            let start = 0;
            let end = arr.length - 1;
            let swapped = true;
            while (swapped) {
                swapped = false;
                for (let i = start; i < end; i++) {
                    steps.push({ array: [...arr], highlights: [i, i + 1] });
                    if (arr[i] > arr[i + 1]) {
                        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
                        steps.push({ array: [...arr], highlights: [i, i + 1] });
                        swapped = true;
                    }
                }
                if (!swapped) break;
                swapped = false;
                end--;
                for (let i = end; i > start; i--) {
                    steps.push({ array: [...arr], highlights: [i, i - 1] });
                    if (arr[i] < arr[i - 1]) {
                        [arr[i], arr[i - 1]] = [arr[i - 1], arr[i]];
                        steps.push({ array: [...arr], highlights: [i, i - 1] });
                        swapped = true;
                    }
                }
                start++;
            }
            steps.push({ array: [...arr], highlights: [] });
            return steps;
        }

        function quickSortSteps(array) {
            const arr = [...array];
            const steps = [{ array: [...arr], highlights: [] }];

            function partition(low, high) {
                const pivot = arr[high];
                let i = low;
                for (let j = low; j < high; j++) {
                    steps.push({ array: [...arr], highlights: [j, high] });
                    if (arr[j] < pivot) {
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                        steps.push({ array: [...arr], highlights: [i, j] });
                        i++;
                    }
                }
                [arr[i], arr[high]] = [arr[high], arr[i]];
                steps.push({ array: [...arr], highlights: [i, high] });
                return i;
            }

            function quick(low, high) {
                if (low < high) {
                    const pi = partition(low, high);
                    quick(low, pi - 1);
                    quick(pi + 1, high);
                }
            }

            quick(0, arr.length - 1);
            steps.push({ array: [...arr], highlights: [] });
            return steps;
        }

        function mergeSortSteps(array) {
            const arr = [...array];
            const steps = [{ array: [...arr], highlights: [] }];

            function mergeSort(start, end) {
                if (start >= end) return;
                const mid = Math.floor((start + end) / 2);
                mergeSort(start, mid);
                mergeSort(mid + 1, end);
                merge(start, mid, end);
            }

            function merge(start, mid, end) {
                const left = arr.slice(start, mid + 1);
                const right = arr.slice(mid + 1, end + 1);
                let i = 0;
                let j = 0;
                let k = start;

                while (i < left.length && j < right.length) {
                    const leftIndex = start + i;
                    const rightIndex = mid + 1 + j;
                    steps.push({ array: [...arr], highlights: [leftIndex, rightIndex] });
                    if (left[i] <= right[j]) {
                        arr[k] = left[i++];
                    } else {
                        arr[k] = right[j++];
                    }
                    steps.push({ array: [...arr], highlights: [k] });
                    k++;
                }

                while (i < left.length) {
                    arr[k] = left[i++];
                    steps.push({ array: [...arr], highlights: [k] });
                    k++;
                }

                while (j < right.length) {
                    arr[k] = right[j++];
                    steps.push({ array: [...arr], highlights: [k] });
                    k++;
                }
            }

            mergeSort(0, arr.length - 1);
            steps.push({ array: [...arr], highlights: [] });
            return steps;
        }

        function heapSortSteps(array) {
            const arr = [...array];
            const steps = [{ array: [...arr], highlights: [] }];
            const n = arr.length;

            function heapify(length, i) {
                let largest = i;
                const left = 2 * i + 1;
                const right = 2 * i + 2;

                if (left < length) {
                    steps.push({ array: [...arr], highlights: [i, left] });
                    if (arr[left] > arr[largest]) {
                        largest = left;
                    }
                }

                if (right < length) {
                    steps.push({ array: [...arr], highlights: [largest, right] });
                    if (arr[right] > arr[largest]) {
                        largest = right;
                    }
                }

                if (largest !== i) {
                    [arr[i], arr[largest]] = [arr[largest], arr[i]];
                    steps.push({ array: [...arr], highlights: [i, largest] });
                    heapify(length, largest);
                }
            }

            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                heapify(n, i);
            }

            for (let i = n - 1; i > 0; i--) {
                [arr[0], arr[i]] = [arr[i], arr[0]];
                steps.push({ array: [...arr], highlights: [0, i] });
                heapify(i, 0);
            }

            steps.push({ array: [...arr], highlights: [] });
            return steps;
        }

        function shellSortSteps(array) {
            const arr = [...array];
            const steps = [{ array: [...arr], highlights: [] }];
            let gap = Math.floor(arr.length / 2);

            while (gap > 0) {
                for (let i = gap; i < arr.length; i++) {
                    const temp = arr[i];
                    let j = i;
                    steps.push({ array: [...arr], highlights: [i] });
                    while (j >= gap && arr[j - gap] > temp) {
                        arr[j] = arr[j - gap];
                        steps.push({ array: [...arr], highlights: [j, j - gap] });
                        j -= gap;
                    }
                    arr[j] = temp;
                    steps.push({ array: [...arr], highlights: [j] });
                }
                gap = Math.floor(gap / 2);
            }

            steps.push({ array: [...arr], highlights: [] });
            return steps;
        }

        function gnomeSortSteps(array) {
            const arr = [...array];
            const steps = [{ array: [...arr], highlights: [] }];
            let index = 0;

            while (index < arr.length) {
                if (index === 0) {
                    index++;
                    continue;
                }
                steps.push({ array: [...arr], highlights: [index, index - 1] });
                if (arr[index] >= arr[index - 1]) {
                    index++;
                } else {
                    [arr[index], arr[index - 1]] = [arr[index - 1], arr[index]];
                    steps.push({ array: [...arr], highlights: [index, index - 1] });
                    index--;
                }
            }

            steps.push({ array: [...arr], highlights: [] });
            return steps;
        }

        function radixSortSteps(array) {
            const arr = [...array];
            const steps = [{ array: [...arr], highlights: [] }];
            const max = Math.max(...arr, 0);
            let exp = 1;

            while (Math.floor(max / exp) > 0) {
                const output = new Array(arr.length).fill(0);
                const count = new Array(10).fill(0);

                for (let i = 0; i < arr.length; i++) {
                    const digit = Math.floor(arr[i] / exp) % 10;
                    count[digit]++;
                    steps.push({ array: [...arr], highlights: [i] });
                }

                for (let i = 1; i < 10; i++) {
                    count[i] += count[i - 1];
                }

                for (let i = arr.length - 1; i >= 0; i--) {
                    const digit = Math.floor(arr[i] / exp) % 10;
                    output[count[digit] - 1] = arr[i];
                    count[digit]--;
                }

                for (let i = 0; i < arr.length; i++) {
                    arr[i] = output[i];
                    steps.push({ array: [...arr], highlights: [i] });
                }

                exp *= 10;
            }

            steps.push({ array: [...arr], highlights: [] });
            return steps;
        }
    </script>
</body>
</html>
