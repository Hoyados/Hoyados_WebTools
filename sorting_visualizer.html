<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ソートアルゴリズム可視化ツール</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f7f9fc;
            margin: 0;
            padding: 0;
            color: #1f2a44;
        }
        .container {
            max-width: 1100px;
            margin: 0 auto;
            padding: 20px 24px 40px;
        }
        .back-link {
            display: inline-block;
            margin-bottom: 20px;
            padding: 6px 14px;
            border-radius: 6px;
            background-color: #f0f4ff;
            color: #1a4fbf;
            text-decoration: none;
            font-weight: bold;
        }
        .back-link:hover {
            background-color: #d9e4ff;
        }
        h1 {
            margin: 0 0 12px;
        }
        p.description {
            margin-top: 0;
            color: #4b5567;
        }
        .controls, .actions {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            align-items: center;
            margin-bottom: 16px;
            background-color: #fff;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
        }
        .controls label,
        .actions label {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .controls input[type="number"] {
            width: 80px;
            padding: 4px 6px;
        }
        button {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background-color: #4a90e2;
            color: white;
            font-weight: bold;
        }
        button:disabled {
            background-color: #9fbbe0;
            cursor: not-allowed;
        }
        button.secondary {
            background-color: #6b7a99;
        }
        .algorithms {
            background-color: #fff;
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            margin-bottom: 16px;
        }
        .algorithm-options {
            display: flex;
            flex-wrap: wrap;
            gap: 10px 18px;
            margin-top: 8px;
        }
        .algorithm-options label {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        #sequenceDisplay {
            margin-bottom: 18px;
            font-family: "Courier New", Courier, monospace;
            background-color: #fff;
            padding: 10px 14px;
            border-radius: 8px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            min-height: 38px;
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 6px;
        }
        .alert {
            background-color: #ffe1e1;
            color: #8a1c1c;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 16px;
        }
        .alert.hidden {
            display: none;
        }
        .panels {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
        }
        .panel {
            background-color: #fff;
            padding: 14px 16px 18px;
            border-radius: 10px;
            box-shadow: 0 1px 4px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }
        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 10px;
        }
        .panel-header h3 {
            margin: 0;
            font-size: 18px;
        }
        .timer {
            font-size: 14px;
            color: #4b5567;
        }
        .bars {
            position: relative;
            flex: 1;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 4px;
            height: 220px;
            padding: 10px;
            background-color: #f6f8fb;
            border-radius: 8px;
        }
        .bar {
            flex: 1;
            min-width: 6px;
            border-radius: 4px 4px 0 0;
            background: linear-gradient(180deg, #7aa6ff, #3c6fe7);
            transition: height 0.13s ease, background-color 0.13s ease;
        }
        .bar.highlight {
            background: linear-gradient(180deg, #ff9387, #ff4c39);
        }
        .status {
            margin-top: 10px;
            min-height: 18px;
            font-size: 14px;
            color: #4b5567;
        }
        .actions input[type="range"] {
            width: 160px;
        }
        .speed-label span {
            font-size: 12px;
            color: #4b5567;
        }
        @media (max-width: 680px) {
            .controls, .actions {
                flex-direction: column;
                align-items: flex-start;
            }
            .panel {
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a class="back-link" href="index.html">← インデックスへ戻る</a>
        <h1>ソートアルゴリズム可視化ツール</h1>
        <p class="description">最大3種類のソートを同じ配列で比較できます。速度や要素数を調整しながら、各アルゴリズムの動きを観察してください。</p>

        <div class="controls">
            <label for="elementCount">要素数:
                <input type="number" id="elementCount" min="5" max="80" value="20">
            </label>
            <button id="randomizeBtn" class="secondary">ランダム配列生成</button>
            <span style="font-size:13px;color:#6b7a99;">※配列は選択したソートで共有されます</span>
        </div>

        <div id="sequenceDisplay"></div>

        <div class="algorithms">
            <strong>アルゴリズムを選択（最大3つ）</strong>
            <div class="algorithm-options" id="algorithmOptions"></div>
        </div>

        <div class="actions">
            <button id="startBtn">ソートを開始</button>
            <label class="speed-label">描画間隔:
                <input type="range" id="speedRange" min="15" max="220" value="80">
                <span id="speedValue">80ms</span>
            </label>
            <span style="font-size:13px;color:#6b7a99;">タイムアウト: 15秒</span>
        </div>

        <div id="alert" class="alert hidden"></div>

        <div id="panels" class="panels"></div>
    </div>

    <script>
        const MAX_ALGORITHMS = 3;
        const TIMEOUT_MS = 15000;
        const algorithms = {
            bubble: { key: "bubble", label: "バブルソート", generator: bubbleSortSteps },
            quick: { key: "quick", label: "クイックソート", generator: quickSortSteps },
            cocktail: { key: "cocktail", label: "カクテルソート", generator: cocktailSortSteps },
            insertion: { key: "insertion", label: "挿入ソート", generator: insertionSortSteps },
            selection: { key: "selection", label: "選択ソート", generator: selectionSortSteps }
        };

        let currentArray = [];

        const elementCountInput = document.getElementById("elementCount");
        const randomizeBtn = document.getElementById("randomizeBtn");
        const startBtn = document.getElementById("startBtn");
        const algorithmOptions = document.getElementById("algorithmOptions");
        const panelsContainer = document.getElementById("panels");
        const alertBox = document.getElementById("alert");
        const sequenceDisplay = document.getElementById("sequenceDisplay");
        const speedRange = document.getElementById("speedRange");
        const speedValue = document.getElementById("speedValue");

        init();

        function init() {
            renderAlgorithmOptions();
            generateNewArray();
            updateSequenceDisplay();
            speedRange.addEventListener("input", () => {
                speedValue.textContent = speedRange.value + "ms";
            });
            randomizeBtn.addEventListener("click", () => {
                generateNewArray();
                updateSequenceDisplay();
                panelsContainer.innerHTML = "";
            });
            elementCountInput.addEventListener("change", () => {
                clampElementCount();
                generateNewArray();
                updateSequenceDisplay();
                panelsContainer.innerHTML = "";
            });
            startBtn.addEventListener("click", startVisualization);
        }

        function renderAlgorithmOptions() {
            Object.values(algorithms).forEach(algo => {
                const id = `algo-${algo.key}`;
                const label = document.createElement("label");
                const input = document.createElement("input");
                input.type = "checkbox";
                input.value = algo.key;
                input.id = id;
                label.appendChild(input);
                const text = document.createTextNode(algo.label);
                label.appendChild(text);
                algorithmOptions.appendChild(label);
            });
        }

        function clampElementCount() {
            const min = parseInt(elementCountInput.min, 10);
            const max = parseInt(elementCountInput.max, 10);
            let value = parseInt(elementCountInput.value, 10);
            if (Number.isNaN(value)) value = min;
            value = Math.min(Math.max(value, min), max);
            elementCountInput.value = value;
            return value;
        }

        function generateNewArray() {
            const count = clampElementCount();
            currentArray = Array.from({ length: count }, () => Math.floor(Math.random() * 90) + 10);
        }

        function updateSequenceDisplay() {
            sequenceDisplay.innerHTML = "";
            currentArray.forEach(value => {
                const span = document.createElement("span");
                span.textContent = value;
                span.style.padding = "4px 6px";
                span.style.borderRadius = "4px";
                span.style.backgroundColor = "#eef3ff";
                span.style.color = "#2b3d6b";
                sequenceDisplay.appendChild(span);
            });
        }

        function startVisualization() {
            hideAlert();
            const selectedKeys = Array.from(algorithmOptions.querySelectorAll("input[type='checkbox']:checked")).map(el => el.value);
            if (selectedKeys.length === 0) {
                showAlert("最低でも1つのアルゴリズムを選択してください。");
                return;
            }
            if (selectedKeys.length > MAX_ALGORITHMS) {
                showAlert(`選択できるのは最大 ${MAX_ALGORITHMS} 種類までです。`);
                return;
            }

            const arrayClone = [...currentArray];
            const delay = parseInt(speedRange.value, 10);

            panelsContainer.innerHTML = "";
            startBtn.disabled = true;
            randomizeBtn.disabled = true;

            const tasks = selectedKeys.map(key => runVisualizationForAlgorithm(key, arrayClone, delay));

            Promise.allSettled(tasks).finally(() => {
                startBtn.disabled = false;
                randomizeBtn.disabled = false;
            });
        }

        async function runVisualizationForAlgorithm(key, baseArray, delay) {
            const algo = algorithms[key];
            const panel = createPanel(algo.label);
            panelsContainer.appendChild(panel.container);

            const { timerEl, statusEl, barsContainer } = panel;
            statusEl.textContent = "実行中...";

            const array = [...baseArray];
            const stepsStart = performance.now();

            let steps;
            try {
                steps = algo.generator(array);
            } catch (err) {
                statusEl.textContent = "ステップ生成に失敗しました。";
                console.error(err);
                return;
            }

            const generationTime = performance.now() - stepsStart;
            const timerController = createTimer(timerEl);
            timerController.start();

            const bars = createBars(barsContainer, steps[0]?.array || array);
            let timedOut = false;
            const timeoutAt = performance.now() + TIMEOUT_MS;

            for (let i = 0; i < steps.length; i++) {
                const step = steps[i];
                updateBars(bars, step.array, step.highlights);
                await wait(delay);

                if (performance.now() > timeoutAt) {
                    timedOut = true;
                    break;
                }
            }

            timerController.stop();

            if (timedOut) {
                statusEl.textContent = "タイムアウトしました。描画を停止しました。";
            } else {
                statusEl.textContent = `完了 (${timerController.elapsedMs.toFixed(0)}ms / ステップ生成 ${generationTime.toFixed(1)}ms)`;
            }
        }

        function createPanel(title) {
            const container = document.createElement("div");
            container.className = "panel";

            const header = document.createElement("div");
            header.className = "panel-header";

            const h3 = document.createElement("h3");
            h3.textContent = title;

            const timerEl = document.createElement("span");
            timerEl.className = "timer";
            timerEl.textContent = "0.0s";

            header.appendChild(h3);
            header.appendChild(timerEl);

            const barsContainer = document.createElement("div");
            barsContainer.className = "bars";

            const statusEl = document.createElement("div");
            statusEl.className = "status";

            container.appendChild(header);
            container.appendChild(barsContainer);
            container.appendChild(statusEl);

            return { container, timerEl, statusEl, barsContainer };
        }

        function createBars(container, values) {
            container.innerHTML = "";
            const maxValue = Math.max(...values, 100);
            return values.map(value => {
                const bar = document.createElement("div");
                bar.className = "bar";
                bar.style.height = calculateBarHeight(value, maxValue);
                container.appendChild(bar);
                return bar;
            });
        }

        function updateBars(bars, values, highlights = []) {
            const maxValue = Math.max(...values, 100);
            bars.forEach((bar, index) => {
                if (!bar) return;
                const value = values[index] ?? 0;
                bar.style.height = calculateBarHeight(value, maxValue);
                bar.classList.toggle("highlight", highlights.includes(index));
            });
        }

        function calculateBarHeight(value, maxValue) {
            const normalized = maxValue === 0 ? 0 : value / maxValue;
            const height = Math.max(12, normalized * 200);
            return `${height}px`;
        }

        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function createTimer(timerEl) {
            let startTime = 0;
            let rafId = null;
            const controller = {
                elapsedMs: 0,
                start() {
                    startTime = performance.now();
                    const tick = () => {
                        controller.elapsedMs = performance.now() - startTime;
                        timerEl.textContent = (controller.elapsedMs / 1000).toFixed(1) + "s";
                        rafId = requestAnimationFrame(tick);
                    };
                    tick();
                },
                stop() {
                    if (rafId !== null) {
                        cancelAnimationFrame(rafId);
                        rafId = null;
                    }
                    timerEl.textContent = (controller.elapsedMs / 1000).toFixed(1) + "s";
                }
            };
            return controller;
        }

        function showAlert(message) {
            alertBox.textContent = message;
            alertBox.classList.remove("hidden");
        }

        function hideAlert() {
            alertBox.classList.add("hidden");
        }

        // ---- Sorting step generators ----

        function bubbleSortSteps(array) {
            const arr = [...array];
            const steps = [{ array: [...arr], highlights: [] }];
            const n = arr.length;
            for (let i = 0; i < n - 1; i++) {
                for (let j = 0; j < n - i - 1; j++) {
                    steps.push({ array: [...arr], highlights: [j, j + 1] });
                    if (arr[j] > arr[j + 1]) {
                        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
                        steps.push({ array: [...arr], highlights: [j, j + 1] });
                    }
                }
            }
            steps.push({ array: [...arr], highlights: [] });
            return steps;
        }

        function insertionSortSteps(array) {
            const arr = [...array];
            const steps = [{ array: [...arr], highlights: [] }];
            for (let i = 1; i < arr.length; i++) {
                let key = arr[i];
                let j = i - 1;
                steps.push({ array: [...arr], highlights: [i] });
                while (j >= 0 && arr[j] > key) {
                    arr[j + 1] = arr[j];
                    steps.push({ array: [...arr], highlights: [j, j + 1] });
                    j--;
                }
                arr[j + 1] = key;
                steps.push({ array: [...arr], highlights: [j + 1] });
            }
            steps.push({ array: [...arr], highlights: [] });
            return steps;
        }

        function selectionSortSteps(array) {
            const arr = [...array];
            const steps = [{ array: [...arr], highlights: [] }];
            const n = arr.length;
            for (let i = 0; i < n - 1; i++) {
                let minIdx = i;
                for (let j = i + 1; j < n; j++) {
                    steps.push({ array: [...arr], highlights: [minIdx, j] });
                    if (arr[j] < arr[minIdx]) {
                        minIdx = j;
                    }
                }
                if (minIdx !== i) {
                    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];
                    steps.push({ array: [...arr], highlights: [i, minIdx] });
                }
            }
            steps.push({ array: [...arr], highlights: [] });
            return steps;
        }

        function cocktailSortSteps(array) {
            const arr = [...array];
            const steps = [{ array: [...arr], highlights: [] }];
            let start = 0;
            let end = arr.length - 1;
            let swapped = true;
            while (swapped) {
                swapped = false;
                for (let i = start; i < end; i++) {
                    steps.push({ array: [...arr], highlights: [i, i + 1] });
                    if (arr[i] > arr[i + 1]) {
                        [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]];
                        steps.push({ array: [...arr], highlights: [i, i + 1] });
                        swapped = true;
                    }
                }
                if (!swapped) break;
                swapped = false;
                end--;
                for (let i = end; i > start; i--) {
                    steps.push({ array: [...arr], highlights: [i, i - 1] });
                    if (arr[i] < arr[i - 1]) {
                        [arr[i], arr[i - 1]] = [arr[i - 1], arr[i]];
                        steps.push({ array: [...arr], highlights: [i, i - 1] });
                        swapped = true;
                    }
                }
                start++;
            }
            steps.push({ array: [...arr], highlights: [] });
            return steps;
        }

        function quickSortSteps(array) {
            const arr = [...array];
            const steps = [{ array: [...arr], highlights: [] }];

            function partition(low, high) {
                const pivot = arr[high];
                let i = low;
                for (let j = low; j < high; j++) {
                    steps.push({ array: [...arr], highlights: [j, high] });
                    if (arr[j] < pivot) {
                        [arr[i], arr[j]] = [arr[j], arr[i]];
                        steps.push({ array: [...arr], highlights: [i, j] });
                        i++;
                    }
                }
                [arr[i], arr[high]] = [arr[high], arr[i]];
                steps.push({ array: [...arr], highlights: [i, high] });
                return i;
            }

            function quick(low, high) {
                if (low < high) {
                    const pi = partition(low, high);
                    quick(low, pi - 1);
                    quick(pi + 1, high);
                }
            }

            quick(0, arr.length - 1);
            steps.push({ array: [...arr], highlights: [] });
            return steps;
        }
    </script>
</body>
</html>
